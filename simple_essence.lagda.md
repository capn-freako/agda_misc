---
format: 'markdown+latex'
title: 'Agda Doodlings Involving Linearity & Vector Spaces'
description: Agda proofs of some isomorphisms revealed by Conal in his paper.
author: 'David Banas <capn.freako@gmail.com>'
date: 2022-04-02
copy: Copyright (c) 2022 David Banas; all rights reserved World wide.
...

{% include mathjax.html %}

<link rel="stylesheet" type="text/css" href="Agda.css">

In this [literate Agda](https://agda.readthedocs.io/en/v2.6.2.1/tools/literate-programming.html#literate-markdown) file I'm exploring some of the ideas written about by Conal Elliott in his paper: _The Simple Essence of Automatic Differentiation_.
In particular, I'm attempting to prove, using Agda, some of the isomorphisms that Conal reveals in that paper.

## Introduction

In (re)reading Conal's paper, I noticed something that I thought was a typo:

> The internal representation of $$Cont^{s}_{(‚ä∏)} \, a \, b$$ is $$(b ‚ä∏ s) ‚Üí (a ‚ä∏ s)$$, which is isomorphic to $$b ‚Üí a$$.

I thought for sure Conal meant to say:

> ... isomorphic to $$a ‚Üí b$$.

since the continuation must "know" how to get from `a` to `b`, in order to offer the type signature it does.
(Can this be proven in Agda, perhaps by using a proof-by-contradiction approach?)

But, when I discussed this with Conal, he drew my attention to the paragraph immediately above, in which he points out:

> In particular, every linear map in $$A ‚ä∏ s$$ has the form `dot u` for some `u :: A`,

And that, therefore, since $$a ‚ä∏ s$$ is isomorphic to $$a$$,  $$(b ‚ä∏ s) ‚Üí (a ‚ä∏ s)$$ is indeed isomorphic to $$b ‚Üí a$$.

Well, that's very interesting, because now we've got something (the _continuation_) that is isomorphic to both $$a ‚Üí b$$ and $$b ‚Üí a$$.
And, because the isomorphism relation is _transitive_, that means: $$a ‚Üí b ‚âÖ b ‚Üí a$$!
Of course, this only holds in the special case where both types $$a$$ and $$b$$ have linear maps to the underlying scalar field.
And the existence of this duality under this very special condition is sort of the punchline of Conal's paper.
Nevertheless, it struck me as quite powerful to be able to prove, at the outset and using Agda, that the duality must exist.

## Preliminaries

First, we need to codify in Agda what we mean by a _linear map_.
We'll take Conal's definition: a linear map is...

> a function that distributes over tensor addition and scalar multiplication.

That is:

$$
f : A \to B
$$

and:

$$
f (x \oplus y)  = f x \oplus f y
$$

$$
f (s \otimes x) = s \otimes f x
$$

Right away, we've identified several necessities, in addition to those explicitly written above:

1. The $$\oplus$$ operator must take two arguments of the same type and combine them, returning a result also within the type.

1. Both types $$A$$ and $$B$$ _must_ have the $$\oplus$$ operator defined on them.

1. The $$\otimes$$ operator must take a scalar as its first argument and some type as its second, returning a result value within that type.

1. Both types $$A$$ and $$B$$ _must_ have the $$\otimes$$ operator defined on them.

We can codify all this in Agda fairly easily:

    {% highlight haskell linenos %}
    data ¬ß : Set where
      ¬ß : ¬ß

    record Additive (A : Set) : Set where
      infixl 6 _‚äï_  -- Just matching associativity/priority of `_+_`.
      field
        _‚äï_ : A ‚Üí A ‚Üí A

    record Scalable (A : Set) : Set where
      infixl 7 _‚äõ_  -- Just matching associativity/priority of `_*_`.
      field
        _‚äõ_ : ¬ß ‚Üí A ‚Üí A

    record LinMap {A B : Set}
                  ‚¶É_ : Additive A‚¶Ñ ‚¶É_ : Additive B‚¶Ñ
                  ‚¶É_ : Scalable A‚¶Ñ ‚¶É_ : Scalable B‚¶Ñ
                  : Set where
      field
        f      : A ‚Üí B

        adds   : ‚àÄ (a b : A)
                 ----------------------
               ‚Üí f (a ‚äï b) ‚â° f a ‚äï f b

        scales : ‚àÄ (s : ¬ß) (a : A)
                 --------------------
               ‚Üí f (s ‚äõ a) ‚â° s ‚äõ f a
    {% endhighlight %}

## Additional Requirements

Okay, let's see if what we've got so far is enough to attack the first isomorphism I'd like to prove: `A ‚ä∏ ¬ß ‚âÖ A`, i.e., a linear map from type `A` to scalar is isomorphic to the type `A` itself.
Proving this isomorphism in Agda amounts to constructing the following record:

    {% highlight haskell linenos %}
    a‚ä∏¬ß‚âÉa : ‚àÄ {A : Set} ‚¶É_ : Additive A‚¶Ñ ‚¶É_ : Scalable A‚¶Ñ
             --------------------------------------------
           ‚Üí LinMap {A} {¬ß} ‚âÉ A
    a‚ä∏¬ß‚âÉa = record
      { to   = Œª { lm ‚Üí ? }
      ; from = Œª { a  ‚Üí ? }
      ; from‚àòto = ?
      ; to‚àòfrom = ?
      }
    {% endhighlight %}

Now, how to implement `to` and `from`?

If we required that `Additive` provide a _left identity_ for `‚äï` then it would be enough to require that `A` be able to produce an iterable set of basis vectors.
In that case, `to` could be implemented, via the following:

{% highlight haskell linenos %}
    to = Œª lm ‚Üí foldl (Œª acc v ‚Üí acc ‚äï (lm.f v) ‚äõ v) id-‚äï vs
{% endhighlight %}

Implementing `from` is fairly simple, but does require that `A` have an inner product.
In that case, we just build a `LinMap` record where `f` takes the dot product of its
input w/ `a`.

**Note:** My hunch is that I'm going to have to define some property of type `A` that relates the "inner product" to its "basis vectors", in order to tie all this together, but it's unclear to me what that property is, or needs to be.

## First Proof Attempt

Let's try adding the extra necessities identified above and attacking the proof.
I'll note any additional properties, record fields, etc. needed to complete the proof, via Agda comments, for subsequent discussion.

### Imports, Variables, and Postulates

Here, we import everything we'll need later and define our module-wide variables and postulates.

```agda
module simple_essence where

open import Agda.Builtin.Sigma
open import Algebra                            using (IsRing; IsNearSemiring)
open import Axiom.Extensionality.Propositional using (Extensionality)
open import Data.List
open import Data.Product using (Œ£; _,_; ‚àÉ; Œ£-syntax; ‚àÉ-syntax)
open import Function     using (_‚Üî_; mk‚Üî; id; const)
open import Level        using (Level; _‚äî_)

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_‚â°_; refl; trans; sym; cong; cong‚ÇÇ; cong-app; subst; _‚â¢_)
open Eq.‚â°-Reasoning                   using (begin_; _‚â°‚ü®‚ü©_; step-‚â°; _‚àé)
open import Relation.Nullary          using (¬¨_)
open import Relation.Nullary.Negation using (contraposition)

variable
  ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ ‚Ñì‚ÇÉ : Level
  
postulate
  extensionality : Extensionality ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ

```

### Type Classes

Here, we define the abstract type classes we'll be using in our proofs.
We use a slight variation on the approach taken in the standard library "bundles", because it yields cleaner, more succinct, abstract code capable of _automatic instance selection_.

**Note:** We've removed our previously defined custom typeclass: `Additive`, in favor of `Ring` defined in the Agda standard library.
We've kept `Scalable`, for now, in order to get some incremental progress working and checked in before attempting to use `Module` and friends.

```agda
record Scalable (T : Set ‚Ñì‚ÇÅ) (A : Set ‚Ñì‚ÇÅ) : Set (Level.suc ‚Ñì‚ÇÅ) where
  infix 7 _¬∑_
  field
    _¬∑_ : A ‚Üí T ‚Üí T
open Scalable ‚¶É ... ‚¶Ñ public

record Ring (A : Set ‚Ñì‚ÇÅ) : Set (Level.suc ‚Ñì‚ÇÅ) where
  infixl 6 _+_
  infixl 7 _*_
  infix  8 -_
  field
    _+_ : A ‚Üí A ‚Üí A
    _*_ : A ‚Üí A ‚Üí A
    -_  : A ‚Üí A
    ùüò   : A
    ùüô   : A
    ‚¶É isRing ‚¶Ñ : IsRing _‚â°_ _+_ _*_ -_ ùüò ùüô
  open IsRing isRing public
  instance
    scalableRing : Scalable A A
    scalableRing = record
      { _¬∑_ = _*_
      }
  open Scalable scalableRing
open Ring ‚¶É ... ‚¶Ñ public
    
```

### Linear Maps

Here, we capture our intended meaning of _linearity_.

We take the vector-centric definition offered by Conal in his paper:

> A linear map is one that distributes over _vector_ addition and _scalar_ multiplication.

```agda
record LinMap (A : Set ‚Ñì‚ÇÅ) (B : Set ‚Ñì‚ÇÅ) {¬ß : Set ‚Ñì‚ÇÅ}
              ‚¶É _ : Ring A ‚¶Ñ ‚¶É _ : Ring B ‚¶Ñ
              ‚¶É _ : Scalable A ¬ß ‚¶Ñ   ‚¶É _ : Scalable B ¬ß ‚¶Ñ
              : Set ‚Ñì‚ÇÅ where
  constructor mkLM
  field
    f      : A ‚Üí B

    adds   : ‚àÄ {a b : A}
             ---------------------
          ‚Üí f (a + b) ‚â° f a + f b

    scales : ‚àÄ {s : ¬ß} {a : A}
             -------------------
          ‚Üí f (s ¬∑ a) ‚â° s ¬∑ f a

open LinMap ‚¶É ... ‚¶Ñ public

-- As per Conal's advice:
-- ‚ä∏‚âà = isEquivalence LinMap.f Eq.isEquivalence
postulate
  ‚ä∏‚â° : {A : Set ‚Ñì‚ÇÅ} {B : Set ‚Ñì‚ÇÅ} {¬ß : Set ‚Ñì‚ÇÅ}
       ‚¶É _ : Ring A ‚¶Ñ ‚¶É _ : Ring B ‚¶Ñ
       ‚¶É _ : Scalable A ¬ß ‚¶Ñ ‚¶É _ : Scalable B ¬ß ‚¶Ñ
       {lm‚ÇÅ lm‚ÇÇ : LinMap A B {¬ß}}
    ‚Üí LinMap.f lm‚ÇÅ ‚â° LinMap.f lm‚ÇÇ
       --------------------------
    ‚Üí lm‚ÇÅ ‚â° lm‚ÇÇ

```

### Vector Spaces

Here, we define what we mean by a _vector space_.

In its most general sense, a "vector space" provides a function that takes some _index_ type and uses it to map from some _container_ type to a single value of the _carrier_ type.

We add a few extras, useful when doing _linear algebra_:

Vector Addition
:   We can "add" two vectors, producing a third.

Scalar Multiplication
:   We can "scale" a vector by an element of the carrier type, producing another vector.

Inner Product
:   We can combine two vectors, producing a single value of the carrier type.

**Note:** The remaining definitions in the code below were the result of attempting to solve the first isomorphism.

**Note:** We use `Ring`, as opposed to a `SemiRing`, because that gives us _subtraction_, which allows us to prove _injectivity_ of linear maps, which in turn allows us to replace the `x¬∑z‚â°y¬∑z‚Üíx‚â°y` _postulate_ with an equivalent _proof_.

```agda
record VectorSpace
  (T : Set ‚Ñì‚ÇÅ) (A : Set ‚Ñì‚ÇÅ)
  ‚¶É _ : Ring T ‚¶Ñ ‚¶É _ : Ring A ‚¶Ñ ‚¶É _ : Scalable T A ‚¶Ñ
  : Set (Level.suc ‚Ñì‚ÇÅ) where
  infix  7 _‚äô_
  field
    I     : Set ‚Ñì‚ÇÅ
    index : I ‚Üí T ‚Üí A
    basisSet    : List T
    _‚äô_         : T ‚Üí T ‚Üí A
    -- Added while solving the isomorphism below.
    ‚äô-distrib-+ : ‚àÄ {a b c : T}
                  -------------------------------
               ‚Üí a ‚äô (b + c) ‚â° (a ‚äô b) + (a ‚äô c)
    ‚äô-comm-¬∑    : ‚àÄ {s : A} {a b : T}
                  -------------------------
               ‚Üí a ‚äô (s ¬∑ b) ‚â° s ¬∑ (a ‚äô b)
    orthonormal : ‚àÄ {f : T ‚Üí A}
               ‚Üí {x : T}
                  ------------------------------------
               ‚Üí ( foldl (Œª acc v ‚Üí acc + (f v) ¬∑ v)
                          ùüò basisSet
                  ) ‚äô x ‚â° f x
open VectorSpace ‚¶É ... ‚¶Ñ public

```

### Isomorphism 1: `(A ‚ä∏ s) ‚Üî A`

Here, I prove that a linear map from some "vector" type `T` to a scalar of its _carrier_ type `A` is isomorphic to `T`.

```agda
a‚ä∏¬ß‚Üía : {T : Set ‚Ñì‚ÇÅ} {A : Set ‚Ñì‚ÇÅ}
         ‚¶É _ : Ring T ‚¶Ñ ‚¶É _ : Ring A ‚¶Ñ
         ‚¶É _ : Scalable T A ‚¶Ñ
         ‚¶É _ : VectorSpace T A ‚¶Ñ
         ------------------------------
      ‚Üí LinMap T A {A} ‚Üí T
a‚ä∏¬ß‚Üía = Œª { lm ‚Üí foldl (Œª acc v ‚Üí
                     acc + (LinMap.f lm v) ¬∑ v) ùüò basisSet }

a‚ä∏¬ß‚Üêa : {T : Set ‚Ñì‚ÇÅ} {A : Set ‚Ñì‚ÇÅ}
         ‚¶É _ : Ring T ‚¶Ñ ‚¶É _ : Ring A ‚¶Ñ
         ‚¶É _ : Scalable T A ‚¶Ñ
         ‚¶É _ : VectorSpace T A ‚¶Ñ
         --------------------------------------
      ‚Üí T ‚Üí LinMap T A {A}
a‚ä∏¬ß‚Üêa = Œª { a ‚Üí mkLM (a ‚äô_) ‚äô-distrib-+ ‚äô-comm-¬∑ }

-- Danger, Will Robinson!
postulate
  x¬∑z‚â°y¬∑z‚Üíx‚â°y : {T : Set ‚Ñì‚ÇÅ} {A : Set ‚Ñì‚ÇÅ}
                 ‚¶É _ : Ring T ‚¶Ñ ‚¶É _ : Ring A ‚¶Ñ
                 ‚¶É _ : Scalable T A ‚¶Ñ ‚¶É _ : VectorSpace T A ‚¶Ñ
                 {x y : T}
              ‚Üí (‚àÄ {z : T} ‚Üí x ‚äô z ‚â° y ‚äô z)
                 ---------------------------------------------
              ‚Üí x ‚â° y
-- ToDo: Try replacing postulate above w/ definition below.
--       (Perhaps, a proof by contradiction, starting w/ `x ‚â¢ y`?)
-- x¬∑z‚â°y¬∑z‚Üíx‚â°y x¬∑z‚â°y¬∑z = {!!}

a‚ä∏¬ß‚Üîa : {T : Set ‚Ñì‚ÇÅ} {A : Set ‚Ñì‚ÇÅ}
         ‚¶É _ : Ring T ‚¶Ñ ‚¶É _ : Ring A ‚¶Ñ
         ‚¶É _ : Scalable T A ‚¶Ñ ‚¶É _ : VectorSpace T A ‚¶Ñ
         ---------------------------------------------
      ‚Üí (LinMap T A) ‚Üî T
a‚ä∏¬ß‚Üîa =
  mk‚Üî {f = a‚ä∏¬ß‚Üía} {f‚Åª¬π = a‚ä∏¬ß‚Üêa}
      ( (Œª {x ‚Üí begin
                  a‚ä∏¬ß‚Üía (a‚ä∏¬ß‚Üêa x)
                ‚â°‚ü®‚ü©
                  a‚ä∏¬ß‚Üía (mkLM (x ‚äô_) ‚äô-distrib-+ ‚äô-comm-¬∑)
                ‚â°‚ü®‚ü©
                  foldl (Œª acc v ‚Üí acc + (x ‚äô v) ¬∑ v) ùüò basisSet
                ‚â°‚ü® x¬∑z‚â°y¬∑z‚Üíx‚â°y orthonormal ‚ü©
                  x
                ‚àé})
      , Œª {lm ‚Üí begin
                    a‚ä∏¬ß‚Üêa (a‚ä∏¬ß‚Üía lm)
                  ‚â°‚ü®‚ü©
                    a‚ä∏¬ß‚Üêa (foldl (Œª acc v ‚Üí
                                     acc + (LinMap.f lm v) ¬∑ v) ùüò basisSet)
                  ‚â°‚ü®‚ü©
                    mkLM ( foldl ( Œª acc v ‚Üí
                                     acc + (LinMap.f lm v) ¬∑ v
                                 ) ùüò basisSet
                           ‚äô_
                         ) ‚äô-distrib-+ ‚äô-comm-¬∑
                  ‚â°‚ü® ‚ä∏‚â° ( extensionality
                            ( Œª x ‚Üí orthonormal {f = LinMap.f lm} {x = x} )
                        )
                   ‚ü©
                    lm
                  ‚àé}
      )

```

### Stashed

Stashed coding attempts.

```agda
-- This, done in response to Conal's suggestion of using `Equivalence`, instead of
-- `Equality`, compiles fine but seems too easy and too weak.
-- There's no guarantee of returning back where we started after a double pass, for instance.
-- I think that I didn't fully grok the hint he was giving me.
--
-- a‚ä∏¬ß‚áîa : {A : Set a}
--         ‚¶É_ : Additive A‚¶Ñ ‚¶É_ : Scalable A‚¶Ñ
--         ‚¶É_ : VectorSpace A‚¶Ñ
--         -------------------------------------
--       ‚Üí (LinMap A ¬ß) ‚áî A
-- a‚ä∏¬ß‚áîa {A} = mk‚áî a‚ä∏¬ß‚Üía a‚ä∏¬ß‚Üêa

-- -- f(0) = 0
-- zero-lin : {A B : Set a}
--           ‚¶É _ : Additive A ‚¶Ñ ‚¶É _ : Additive B ‚¶Ñ
--           ‚¶É _ : Scalable A ‚¶Ñ ‚¶É _ : Scalable B ‚¶Ñ
--           ‚¶É _ : LinMap A B ‚¶Ñ

-- -- Injectivity of linear function
-- inj-lin : {A B : Set a} {x y : A}
--           ‚¶É _ : Additive A ‚¶Ñ ‚¶É _ : Additive B ‚¶Ñ
--           ‚¶É _ : Scalable A ‚¶Ñ ‚¶É _ : Scalable B ‚¶Ñ
--           ‚¶É _ : LinMap A B ‚¶Ñ
--        ‚Üí LinMap.f _ x ‚â° LinMap.f _ y
--           ---------------------------
--        ‚Üí x ‚â° y
-- inj-lin {x = x} {y = y} fx‚â°fy =
--   let f = LinMap.f _
--    in begin
--         x
--       ‚â°‚ü®‚ü©
--         f (x - y)
--       ‚â°‚ü® LinMap.adds _ ‚ü©
--         f x - f y
--       ‚â°‚ü® sub-‚â° fx‚â°fy ‚ü©
--         0
--       ‚â°‚ü®‚ü©
--         y
--       ‚àé
      
-- cong-app‚Ä≤ : ‚àÄ {A : Set a} {B : Set b} {f : A ‚Üí B} {x y : A}
--          ‚Üí f x ‚â° f y
--             ---------
--          ‚Üí x ‚â° y
-- cong-app‚Ä≤ fx‚â°fy = {!contraposition!}
         
-- x¬∑z‚â°y¬∑z‚Üíx‚â°y : {A : Set a}
--                ‚¶É _ : Additive A ‚¶Ñ ‚¶É _ : Scalable A ‚¶Ñ
--                ‚¶É _ : VectorSpace A ‚¶Ñ ‚¶É _ : LinMap A ¬ß ‚¶Ñ
--                {x y : A}
--             ‚Üí (‚àÄ {z : A} ‚Üí x ¬∑ z ‚â° y ¬∑ z)
--                ------------------------------------------------------------
--             ‚Üí x ‚â° y
-- x¬∑z‚â°y¬∑z‚Üíx‚â°y {x = x} {y = y} g =
--   let f = LinMap.f _
--       z = foldl (Œª acc v ‚Üí acc ‚äï f v ‚äõ v) id‚äï basisSet
--       x¬∑z‚â°y¬∑z = g {z}
--    in cong-app refl {!!}
--    -- in begin
--    --      -- ?
--    --      x¬∑z‚â°y¬∑z
--    --    -- ‚â°‚ü® ? ‚ü©
--    --    --   x ¬∑ z ‚â° y ¬∑ z
--    --    ‚â°‚ü® ? ‚ü©
--    --    -- ‚â°‚ü® cong (_‚â° y ¬∑ z) comm-¬∑ ‚ü©
--    --      z ¬∑ x ‚â° y ¬∑ z
--    --    ‚â°‚ü® ? ‚ü©
--    --    -- ‚â°‚ü® cong (z ¬∑ x ‚â°_) comm-¬∑ ‚ü©
--    --      z ¬∑ x ‚â° z ¬∑ y
--    --    ‚â°‚ü® ? ‚ü©
--    --    -- ‚â°‚ü® cong (_‚â° z ¬∑ y) (orthonormal) ‚ü©
--    --      f x ‚â° z ¬∑ y
--    --    ‚â°‚ü® ? ‚ü©
--    --    -- ‚â°‚ü® cong (f x ‚â°_) (orthonormal) ‚ü©
--    --      f x ‚â° f y
--    --    ‚â°‚ü® ? ‚ü©
--    --    -- ‚â°‚ü® cong-app ‚ü©
--    --      x ‚â° y
--    --    ‚àé

-- -- So, how was Agsy able to jump over all of that?
-- -- My usual experience w/ Agsy is that when I ask it to solve anything
-- -- non-trivial by itself it always complains, "Sorry, I don't support
-- -- literals, yet.", which I've never understood.

-- a‚ä∏¬ß‚Üîa : {A : Set a}
--          ‚¶É _ : Additive A ‚¶Ñ ‚¶É _ : Scalable A ‚¶Ñ
--          ‚¶É _ : VectorSpace A ‚¶Ñ ‚¶É _ : LinMap A ¬ß ‚¶Ñ
--          -----------------------------------------
--       ‚Üí (LinMap A ¬ß) ‚Üî A
-- a‚ä∏¬ß‚Üîa {A} =
--   mk‚Üî {f = a‚ä∏¬ß‚Üía} {f‚Åª¬π = a‚ä∏¬ß‚Üêa}
--       ( (Œª {x ‚Üí begin
--                   a‚ä∏¬ß‚Üía (a‚ä∏¬ß‚Üêa x)
--                 ‚â°‚ü®‚ü©
--                   a‚ä∏¬ß‚Üía (mkLM (x ¬∑_) ¬∑-distrib-‚äï ¬∑-comm-‚äõ)
--                 ‚â°‚ü®‚ü©
--                   foldl (Œª acc v ‚Üí acc ‚äï (x ¬∑ v) ‚äõ v) id‚äï basisSet
--                 ‚â°‚ü® x¬∑z‚â°y¬∑z‚Üíx‚â°y (orthonormal {f = (x ¬∑_)}) ‚ü©
--                   x
--                 ‚àé})
--       , Œª {lm ‚Üí begin
--                   a‚ä∏¬ß‚Üêa (a‚ä∏¬ß‚Üía lm)
--                 ‚â°‚ü®‚ü©
--                   a‚ä∏¬ß‚Üêa (foldl (Œª acc v ‚Üí acc ‚äï (LinMap.f lm v) ‚äõ v) id‚äï basisSet)
--                 ‚â°‚ü®‚ü©
--                   mkLM ((foldl (Œª acc v ‚Üí acc ‚äï (LinMap.f lm v) ‚äõ v) id‚äï basisSet)¬∑_)
--                        ¬∑-distrib-‚äï ¬∑-comm-‚äõ
--                 ‚â°‚ü® ‚ä∏‚â° ( extensionality
--                           ( Œª x ‚Üí orthonormal {f = LinMap.f lm} {x = x} )
--                       )
--                  ‚ü©
--                   lm
--                 ‚àé}
--       )


```
