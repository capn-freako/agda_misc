<p>{% include mathjax.html %}</p>
<p>In this <a href="https://agda.readthedocs.io/en/v2.6.2.1/tools/literate-programming.html#literate-markdown">literate Agda</a> file I’m exploring some of the ideas written about by Conal Elliott in his paper: <em>The Simple Essence of Automatic Differentiation</em>. In particular, I’m attempting to prove, using Agda, some of the isomorphisms that Conal reveals in that paper.</p>
<h2 id="introduction">Introduction</h2>
<p>In (re)reading Conal’s paper, I noticed something that I thought was a typo:</p>
<blockquote>
<p>The internal representation of <br /><span class="math display"><em>C</em><em>o</em><em>n</em><em>t</em><sub>( ⊸ )</sub><sup><em>s</em></sup> <em>a</em> <em>b</em></span><br /> is <br /><span class="math display">(<em>b</em> ⊸ <em>s</em>) → (<em>a</em> ⊸ <em>s</em>)</span><br />, which is isomorphic to <br /><span class="math display"><em>b</em> → <em>a</em></span><br />.</p>
</blockquote>
<p>I thought for sure Conal meant to say:</p>
<blockquote>
<p>… isomorphic to <br /><span class="math display"><em>a</em> → <em>b</em></span><br />.</p>
</blockquote>
<p>since the continuation must “know” how to get from <code>a</code> to <code>b</code>, in order to offer the type signature it does. (Can this be proven in Agda, perhaps by using a proof-by-contradiction approach?)</p>
<p>But, when I discussed this with Conal, he drew my attention to the paragraph immediately above, in which he points out:</p>
<blockquote>
<p>In particular, every linear map in <br /><span class="math display"><em>A</em> ⊸ <em>s</em></span><br /> has the form <code>dot u</code> for some <code>u :: A</code>,</p>
</blockquote>
<p>And that, therefore, since <br /><span class="math display"><em>a</em> ⊸ <em>s</em></span><br /> is isomorphic to <br /><span class="math display"><em>a</em></span><br />, <br /><span class="math display">(<em>b</em> ⊸ <em>s</em>) → (<em>a</em> ⊸ <em>s</em>)</span><br /> is indeed isomorphic to <br /><span class="math display"><em>b</em> → <em>a</em></span><br />.</p>
<p>Well, that’s very interesting, because now we’ve got something (the <em>continuation</em>) that is isomorphic to both <br /><span class="math display"><em>a</em> → <em>b</em></span><br /> and <br /><span class="math display"><em>b</em> → <em>a</em></span><br />. And, because the isomorphism relation is <em>transitive</em>, that means: <br /><span class="math display"><em>a</em> → <em>b</em> ≅ <em>b</em> → <em>a</em></span><br />! Of course, this only holds in the special case where both types <br /><span class="math display"><em>a</em></span><br /> and <br /><span class="math display"><em>b</em></span><br /> have linear maps to the underlying scalar field. And the existence of this duality under this very special condition is sort of the punchline of Conal’s paper. Nevertheless, it struck me as quite powerful to be able to prove, at the outset and using Agda, that the duality must exist.</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>First, we need to codify in Agda what we mean by a <em>linear map</em>. We’ll take Conal’s definition: a linear map is…</p>
<blockquote>
<p>a function that distributes over tensor addition and scalar multiplication.</p>
</blockquote>
<p>That is:</p>
<p><br /><span class="math display"><em>f</em> : <em>A</em> → <em>B</em></span><br /></p>
<p>and:</p>
<p><br /><span class="math display"><em>f</em>(<em>x</em> ⊕ <em>y</em>) = <em>f</em><em>x</em> ⊕ <em>f</em><em>y</em></span><br /></p>
<p><br /><span class="math display"><em>f</em>(<em>s</em> ⊗ <em>x</em>) = <em>s</em> ⊗ <em>f</em><em>x</em></span><br /></p>
<p>Right away, we’ve identified several necessities, in addition to those explicitly written above:</p>
<ol type="1">
<li><p>The <br /><span class="math display">⊕</span><br /> operator must take two arguments of the same type and combine them, returning a result also within the type.</p></li>
<li><p>Both types <br /><span class="math display"><em>A</em></span><br /> and <br /><span class="math display"><em>B</em></span><br /> <em>must</em> have the <br /><span class="math display">⊕</span><br /> operator defined on them.</p></li>
<li><p>The <br /><span class="math display">⊗</span><br /> operator must take a scalar as its first argument and some type as its second, returning a result value within that type.</p></li>
<li><p>Both types <br /><span class="math display"><em>A</em></span><br /> and <br /><span class="math display"><em>B</em></span><br /> <em>must</em> have the <br /><span class="math display">⊗</span><br /> operator defined on them.</p></li>
</ol>
<p>We can codify all this in Agda fairly easily:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{</span>% highlight haskell linenos %<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> § <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  § <span class="ot">:</span> §</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">record</span> Additive <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="ot">_</span>⊕<span class="ot">_</span>  <span class="co">-- Just matching associativity/priority of `_+_`.</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="ot">_</span>⊕<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">record</span> Scalable <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="ot">_</span>⊛<span class="ot">_</span>  <span class="co">-- Just matching associativity/priority of `_*_`.</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> § <span class="ot">→</span> A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">record</span> LinMap <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">              ⦃<span class="ot">_</span> <span class="ot">:</span> Additive A⦄ ⦃<span class="ot">_</span> <span class="ot">:</span> Additive B⦄</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">              ⦃<span class="ot">_</span> <span class="ot">:</span> Scalable A⦄ ⦃<span class="ot">_</span> <span class="ot">:</span> Scalable B⦄</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">              <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    f      <span class="ot">:</span> A <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">    adds   <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>a b <span class="ot">:</span> A<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">             <span class="co">----------------------</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">           <span class="ot">→</span> f <span class="ot">(</span>a ⊕ b<span class="ot">)</span> ≡ f a ⊕ f b</a>
<a class="sourceLine" id="cb1-25" data-line-number="25"></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    scales <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>s <span class="ot">:</span> §<span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27">             <span class="co">--------------------</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">           <span class="ot">→</span> f <span class="ot">(</span>s ⊛ a<span class="ot">)</span> ≡ s ⊛ f a</a>
<a class="sourceLine" id="cb1-29" data-line-number="29"><span class="ot">{</span>% endhighlight %<span class="ot">}</span></a></code></pre></div>
<h2 id="additional-requirements">Additional Requirements</h2>
<p>Okay, let’s see if what we’ve got so far is enough to attack the first isomorphism I’d like to prove: <code>A ⊸ § ≅ A</code>, i.e., a linear map from type <code>A</code> to scalar is isomorphic to the type <code>A</code> itself. Proving this isomorphism in Agda amounts to constructing the following record:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{</span>% highlight haskell linenos %<span class="ot">}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">a⊸§≃a <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> ⦃<span class="ot">_</span> <span class="ot">:</span> Additive A⦄ ⦃<span class="ot">_</span> <span class="ot">:</span> Scalable A⦄</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">         <span class="co">--------------------------------------------</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">       <span class="ot">→</span> LinMap <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>§<span class="ot">}</span> ≃ A</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">a⊸§≃a <span class="ot">=</span> <span class="kw">record</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="ot">{</span> <span class="kw">to</span>   <span class="ot">=</span> <span class="ot">λ</span> <span class="ot">{</span> lm <span class="ot">→</span> ? <span class="ot">}</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="ot">;</span> from <span class="ot">=</span> <span class="ot">λ</span> <span class="ot">{</span> a  <span class="ot">→</span> ? <span class="ot">}</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="ot">;</span> from∘to <span class="ot">=</span> ?</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="ot">;</span> to∘from <span class="ot">=</span> ?</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="ot">}</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="ot">{</span>% endhighlight %<span class="ot">}</span></a></code></pre></div>
<p>Now, how to implement <code>to</code> and <code>from</code>?</p>
<p>If we required that <code>Additive</code> provide a <em>left identity</em> for <code>⊕</code> then it would be enough to require that <code>A</code> be able to produce an iterable set of basis vectors. In that case, <code>to</code> could be implemented, via the following:</p>
<p>{% highlight haskell linenos %} to = λ lm → foldl (λ acc v → acc ⊕ (lm.f v) ⊛ v) id-⊕ vs {% endhighlight %}</p>
<p>Implementing <code>from</code> is fairly simple, but does require that <code>A</code> have an inner product. In that case, we just build a <code>LinMap</code> record where <code>f</code> takes the dot product of its input w/ <code>a</code>.</p>
<p><strong>Note:</strong> My hunch is that I’m going to have to define some property of type <code>A</code> that relates the “inner product” to its “basis vectors”, in order to tie all this together, but it’s unclear to me what that property is, or needs to be.</p>
<h2 id="first-proof-attempt">First Proof Attempt</h2>
<p>Let’s try adding the extra necessities identified above and attacking the proof. I’ll note any additional properties, record fields, etc. needed to complete the proof, via Agda comments, for subsequent discussion.</p>
<pre class="Agda"><a id="5498" class="Keyword">module</a> <a id="5505" href="simple_essence.html" class="Module Operator">simple_essence</a> <a id="5520" class="Symbol">{</a><a id="5521" href="simple_essence.html#5521" class="Bound">s</a> <a id="5523" href="simple_essence.html#5523" class="Bound">a</a> <a id="5525" href="simple_essence.html#5525" class="Bound">b</a><a id="5526" class="Symbol">}</a> <a id="5528" class="Keyword">where</a>

<a id="5535" class="Keyword">open</a> <a id="5540" class="Keyword">import</a> <a id="5547" href="Agda.Builtin.Sigma.html" class="Module">Agda.Builtin.Sigma</a>
<a id="5566" class="Keyword">open</a> <a id="5571" class="Keyword">import</a> <a id="5578" href="Axiom.Extensionality.Propositional.html" class="Module">Axiom.Extensionality.Propositional</a> <a id="5613" class="Keyword">using</a> <a id="5619" class="Symbol">(</a><a id="5620" href="Axiom.Extensionality.Propositional.html#741" class="Function">Extensionality</a><a id="5634" class="Symbol">)</a>
<a id="5636" class="Keyword">open</a> <a id="5641" class="Keyword">import</a> <a id="5648" href="Data.Float.html" class="Module">Data.Float</a>
<a id="5659" class="Keyword">open</a> <a id="5664" class="Keyword">import</a> <a id="5671" href="Data.List.html" class="Module">Data.List</a>
<a id="5681" class="Keyword">open</a> <a id="5686" class="Keyword">import</a> <a id="5693" href="Function.html" class="Module">Function</a> <a id="5702" class="Keyword">using</a> <a id="5708" class="Symbol">(</a><a id="5709" href="Function.Bundles.html#7902" class="Function Operator">_↔_</a><a id="5712" class="Symbol">;</a> <a id="5714" href="Function.Bundles.html#9488" class="Function">mk↔</a><a id="5717" class="Symbol">;</a> <a id="5719" href="Function.Base.html#615" class="Function">id</a><a id="5721" class="Symbol">)</a>
<a id="5723" class="Keyword">open</a> <a id="5728" class="Keyword">import</a> <a id="5735" href="Level.html" class="Module">Level</a> <a id="5741" class="Keyword">using</a> <a id="5747" class="Symbol">(</a><a id="5748" href="Agda.Primitive.html#423" class="Postulate">Level</a><a id="5753" class="Symbol">;</a> <a id="5755" href="Agda.Primitive.html#636" class="Primitive Operator">_⊔_</a><a id="5758" class="Symbol">)</a>

<a id="5761" class="Keyword">import</a> <a id="5768" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="5806" class="Symbol">as</a> <a id="5809" class="Module">Eq</a>
<a id="5812" class="Keyword">open</a> <a id="5817" href="Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="5820" class="Keyword">using</a> <a id="5826" class="Symbol">(</a><a id="5827" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="5830" class="Symbol">;</a> <a id="5832" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="5836" class="Symbol">;</a> <a id="5838" href="Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a><a id="5843" class="Symbol">;</a> <a id="5845" href="Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="5848" class="Symbol">;</a> <a id="5850" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a><a id="5854" class="Symbol">;</a> <a id="5856" href="Relation.Binary.PropositionalEquality.html#1524" class="Function">cong₂</a><a id="5861" class="Symbol">;</a> <a id="5863" href="Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a><a id="5871" class="Symbol">;</a> <a id="5873" href="Relation.Binary.PropositionalEquality.Core.html#1076" class="Function">subst</a><a id="5878" class="Symbol">)</a>
<a id="5880" class="Keyword">open</a> <a id="5885" href="Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a> <a id="5900" class="Keyword">using</a> <a id="5906" class="Symbol">(</a><a id="5907" href="Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin_</a><a id="5913" class="Symbol">;</a> <a id="5915" href="Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">_≡⟨⟩_</a><a id="5920" class="Symbol">;</a> <a id="5922" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">step-≡</a><a id="5928" class="Symbol">;</a> <a id="5930" href="Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">_∎</a><a id="5932" class="Symbol">)</a>

<a id="5935" class="Keyword">postulate</a>
  <a id="5947" class="Comment">-- This one seems completely safe. Why isn&#39;t it in the standard library?</a>
  <a id="id+"></a><a id="6022" href="simple_essence.html#6022" class="Postulate">id+</a> <a id="6026" class="Symbol">:</a> <a id="6028" class="Symbol">{</a><a id="6029" href="simple_essence.html#6029" class="Bound">x</a> <a id="6031" class="Symbol">:</a> <a id="6033" href="Agda.Builtin.Float.html#292" class="Postulate">Float</a><a id="6038" class="Symbol">}</a> <a id="6040" class="Symbol">→</a> <a id="6042" class="Number">0.0</a> <a id="6046" href="Agda.Builtin.Float.html#606" class="Primitive Operator">+</a> <a id="6048" href="simple_essence.html#6029" class="Bound">x</a> <a id="6050" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6052" href="simple_essence.html#6029" class="Bound">x</a>
  <a id="extensionality"></a><a id="6056" href="simple_essence.html#6056" class="Postulate">extensionality</a> <a id="6071" class="Symbol">:</a> <a id="6073" class="Symbol">∀</a> <a id="6075" class="Symbol">{</a><a id="6076" href="simple_essence.html#6076" class="Bound">ℓ₁</a> <a id="6079" href="simple_essence.html#6079" class="Bound">ℓ₂</a><a id="6081" class="Symbol">}</a> <a id="6083" class="Symbol">→</a> <a id="6085" href="Axiom.Extensionality.Propositional.html#741" class="Function">Extensionality</a> <a id="6100" href="simple_essence.html#6076" class="Bound">ℓ₁</a> <a id="6103" href="simple_essence.html#6079" class="Bound">ℓ₂</a>

<a id="ℓ"></a><a id="6107" href="simple_essence.html#6107" class="Function">ℓ</a> <a id="6109" class="Symbol">:</a> <a id="6111" href="Agda.Primitive.html#423" class="Postulate">Level</a>
<a id="6117" href="simple_essence.html#6107" class="Function">ℓ</a> <a id="6119" class="Symbol">=</a> <a id="6121" href="simple_essence.html#5521" class="Bound">s</a> <a id="6123" href="Agda.Primitive.html#636" class="Primitive Operator">⊔</a> <a id="6125" href="simple_essence.html#5523" class="Bound">a</a> <a id="6127" href="Agda.Primitive.html#636" class="Primitive Operator">⊔</a> <a id="6129" href="simple_essence.html#5525" class="Bound">b</a>

<a id="6132" class="Keyword">data</a> <a id="§"></a><a id="6137" href="simple_essence.html#6137" class="Datatype">§</a> <a id="6139" class="Symbol">:</a> <a id="6141" class="PrimitiveType">Set</a> <a id="6145" href="simple_essence.html#5523" class="Bound">a</a> <a id="6147" class="Keyword">where</a>
  <a id="§.S"></a><a id="6155" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6157" class="Symbol">:</a> <a id="6159" href="Agda.Builtin.Float.html#292" class="Postulate">Float</a> <a id="6165" class="Symbol">→</a> <a id="6167" href="simple_essence.html#6137" class="Datatype">§</a>

<a id="6170" class="Keyword">record</a> <a id="Additive"></a><a id="6177" href="simple_essence.html#6177" class="Record">Additive</a> <a id="6186" class="Symbol">(</a><a id="6187" href="simple_essence.html#6187" class="Bound">A</a> <a id="6189" class="Symbol">:</a> <a id="6191" class="PrimitiveType">Set</a> <a id="6195" href="simple_essence.html#5523" class="Bound">a</a><a id="6196" class="Symbol">)</a> <a id="6198" class="Symbol">:</a> <a id="6200" class="PrimitiveType">Set</a> <a id="6204" href="simple_essence.html#6107" class="Function">ℓ</a> <a id="6206" class="Keyword">where</a>
  <a id="6214" class="Keyword">infixl</a> <a id="6221" class="Number">6</a> <a id="6223" href="simple_essence.html#6303" class="Field Operator">_⊕_</a>  <a id="6228" class="Comment">-- Just matching associativity/priority of `_+_`.</a>
  <a id="6280" class="Keyword">field</a>
    <a id="Additive.id⊕"></a><a id="6290" href="simple_essence.html#6290" class="Field">id⊕</a>  <a id="6295" class="Symbol">:</a> <a id="6297" href="simple_essence.html#6187" class="Bound">A</a>
    <a id="Additive._⊕_"></a><a id="6303" href="simple_essence.html#6303" class="Field Operator">_⊕_</a>  <a id="6308" class="Symbol">:</a> <a id="6310" href="simple_essence.html#6187" class="Bound">A</a> <a id="6312" class="Symbol">→</a> <a id="6314" href="simple_essence.html#6187" class="Bound">A</a> <a id="6316" class="Symbol">→</a> <a id="6318" href="simple_essence.html#6187" class="Bound">A</a>
    <a id="Additive.id-⊕"></a><a id="6324" href="simple_essence.html#6324" class="Field">id-⊕</a> <a id="6329" class="Symbol">:</a> <a id="6331" class="Symbol">(</a><a id="6332" href="simple_essence.html#6332" class="Bound">a</a> <a id="6334" class="Symbol">:</a> <a id="6336" href="simple_essence.html#6187" class="Bound">A</a><a id="6337" class="Symbol">)</a>
           <a id="6350" class="Comment">-----------</a>
         <a id="6371" class="Symbol">→</a> <a id="6373" href="simple_essence.html#6290" class="Field">id⊕</a> <a id="6377" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="6379" href="simple_essence.html#6332" class="Bound">a</a> <a id="6381" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6383" href="simple_essence.html#6332" class="Bound">a</a>
    <a id="6389" class="Comment">-- assoc-⊕ : (x y z : A) → (x ⊕ y) ⊕ z ≡ x ⊕ (y ⊕ z)</a>
<a id="6442" class="Keyword">open</a> <a id="6447" href="simple_essence.html#6177" class="Module">Additive</a> <a id="6456" class="Symbol">{{</a> <a id="6459" class="Symbol">...</a> <a id="6463" class="Symbol">}}</a>
<a id="6466" class="Keyword">instance</a>
  <a id="AdditiveScalar"></a><a id="6477" href="simple_essence.html#6477" class="Function">AdditiveScalar</a> <a id="6492" class="Symbol">:</a> <a id="6494" href="simple_essence.html#6177" class="Record">Additive</a> <a id="6503" href="simple_essence.html#6137" class="Datatype">§</a>
  <a id="6507" href="simple_essence.html#6477" class="Function">AdditiveScalar</a> <a id="6522" class="Symbol">=</a> <a id="6524" class="Keyword">record</a>
    <a id="6535" class="Symbol">{</a> <a id="6537" href="simple_essence.html#6290" class="Field">id⊕</a>  <a id="6542" class="Symbol">=</a> <a id="6544" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6546" class="Number">0.0</a>
    <a id="6554" class="Symbol">;</a> <a id="6556" href="simple_essence.html#6303" class="Field Operator">_⊕_</a>  <a id="6561" class="Symbol">=</a> <a id="6563" class="Symbol">λ</a> <a id="6565" class="Symbol">{(</a><a id="6567" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6569" href="simple_essence.html#6569" class="Bound">x</a><a id="6570" class="Symbol">)</a> <a id="6572" class="Symbol">(</a><a id="6573" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6575" href="simple_essence.html#6575" class="Bound">y</a><a id="6576" class="Symbol">)</a> <a id="6578" class="Symbol">→</a> <a id="6580" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6582" class="Symbol">(</a><a id="6583" href="simple_essence.html#6569" class="Bound">x</a> <a id="6585" href="Agda.Builtin.Float.html#606" class="Primitive Operator">+</a> <a id="6587" href="simple_essence.html#6575" class="Bound">y</a><a id="6588" class="Symbol">)}</a>
    <a id="6595" class="Symbol">;</a> <a id="6597" href="simple_essence.html#6324" class="Field">id-⊕</a> <a id="6602" class="Symbol">=</a> <a id="6604" class="Symbol">λ</a> <a id="6606" class="Symbol">{</a> <a id="6608" class="Symbol">(</a><a id="6609" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6611" href="simple_essence.html#6611" class="Bound">x</a><a id="6612" class="Symbol">)</a> <a id="6614" class="Symbol">→</a> <a id="6616" href="Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
                           <a id="6649" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6651" class="Symbol">(</a><a id="6652" class="Number">0.0</a> <a id="6656" href="Agda.Builtin.Float.html#606" class="Primitive Operator">+</a> <a id="6658" href="simple_essence.html#6611" class="Bound">x</a><a id="6659" class="Symbol">)</a>
                         <a id="6686" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="6689" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="6694" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6696" href="simple_essence.html#6022" class="Postulate">id+</a> <a id="6700" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
                           <a id="6729" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="6731" href="simple_essence.html#6611" class="Bound">x</a>
                         <a id="6758" href="Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
               <a id="6775" class="Symbol">}</a>
    <a id="6781" class="Symbol">}</a>

<a id="6784" class="Keyword">record</a> <a id="Scalable"></a><a id="6791" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="6800" class="Symbol">(</a><a id="6801" href="simple_essence.html#6801" class="Bound">A</a> <a id="6803" class="Symbol">:</a> <a id="6805" class="PrimitiveType">Set</a> <a id="6809" href="simple_essence.html#5523" class="Bound">a</a><a id="6810" class="Symbol">)</a> <a id="6812" class="Symbol">:</a> <a id="6814" class="PrimitiveType">Set</a> <a id="6818" href="simple_essence.html#6107" class="Function">ℓ</a> <a id="6820" class="Keyword">where</a>
  <a id="6828" class="Keyword">infixl</a> <a id="6835" class="Number">7</a> <a id="6837" href="simple_essence.html#6904" class="Field Operator">_⊛_</a>  <a id="6842" class="Comment">-- Just matching associativity/priority of `_*_`.</a>
  <a id="6894" class="Keyword">field</a>
    <a id="Scalable._⊛_"></a><a id="6904" href="simple_essence.html#6904" class="Field Operator">_⊛_</a> <a id="6908" class="Symbol">:</a> <a id="6910" href="simple_essence.html#6137" class="Datatype">§</a> <a id="6912" class="Symbol">→</a> <a id="6914" href="simple_essence.html#6801" class="Bound">A</a> <a id="6916" class="Symbol">→</a> <a id="6918" href="simple_essence.html#6801" class="Bound">A</a>
<a id="6920" class="Keyword">open</a> <a id="6925" href="simple_essence.html#6791" class="Module">Scalable</a> <a id="6934" class="Symbol">{{</a> <a id="6937" class="Symbol">...</a> <a id="6941" class="Symbol">}}</a>
<a id="6944" class="Keyword">instance</a>
  <a id="ScalableScalar"></a><a id="6955" href="simple_essence.html#6955" class="Function">ScalableScalar</a> <a id="6970" class="Symbol">:</a> <a id="6972" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="6981" href="simple_essence.html#6137" class="Datatype">§</a>
  <a id="6985" href="simple_essence.html#6955" class="Function">ScalableScalar</a> <a id="7000" class="Symbol">=</a> <a id="7002" class="Keyword">record</a>
    <a id="7013" class="Symbol">{</a> <a id="7015" href="simple_essence.html#6904" class="Field Operator">_⊛_</a> <a id="7019" class="Symbol">=</a> <a id="7021" class="Symbol">λ</a> <a id="7023" class="Symbol">{(</a><a id="7025" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="7027" href="simple_essence.html#7027" class="Bound">x</a><a id="7028" class="Symbol">)</a> <a id="7030" class="Symbol">(</a><a id="7031" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="7033" href="simple_essence.html#7033" class="Bound">y</a><a id="7034" class="Symbol">)</a> <a id="7036" class="Symbol">→</a> <a id="7038" href="simple_essence.html#6155" class="InductiveConstructor">S</a> <a id="7040" class="Symbol">(</a><a id="7041" href="simple_essence.html#7027" class="Bound">x</a> <a id="7043" href="Agda.Builtin.Float.html#694" class="Primitive Operator">*</a> <a id="7045" href="simple_essence.html#7033" class="Bound">y</a><a id="7046" class="Symbol">)}</a>
    <a id="7053" class="Symbol">}</a>

<a id="7056" class="Keyword">record</a> <a id="LinMap"></a><a id="7063" href="simple_essence.html#7063" class="Record">LinMap</a> <a id="7070" class="Symbol">(</a><a id="7071" href="simple_essence.html#7071" class="Bound">A</a> <a id="7073" class="Symbol">:</a> <a id="7075" class="PrimitiveType">Set</a> <a id="7079" href="simple_essence.html#5523" class="Bound">a</a><a id="7080" class="Symbol">)</a> <a id="7082" class="Symbol">(</a><a id="7083" href="simple_essence.html#7083" class="Bound">B</a> <a id="7085" class="Symbol">:</a> <a id="7087" class="PrimitiveType">Set</a> <a id="7091" href="simple_essence.html#5523" class="Bound">a</a><a id="7092" class="Symbol">)</a>
              <a id="7108" class="Symbol">{{</a><a id="7110" href="simple_essence.html#7110" class="Bound">_</a> <a id="7112" class="Symbol">:</a> <a id="7114" href="simple_essence.html#6177" class="Record">Additive</a> <a id="7123" href="simple_essence.html#7071" class="Bound">A</a><a id="7124" class="Symbol">}}</a> <a id="7127" class="Symbol">{{</a><a id="7129" href="simple_essence.html#7129" class="Bound">_</a> <a id="7131" class="Symbol">:</a> <a id="7133" href="simple_essence.html#6177" class="Record">Additive</a> <a id="7142" href="simple_essence.html#7083" class="Bound">B</a><a id="7143" class="Symbol">}}</a>
              <a id="7160" class="Symbol">{{</a><a id="7162" href="simple_essence.html#7162" class="Bound">_</a> <a id="7164" class="Symbol">:</a> <a id="7166" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="7175" href="simple_essence.html#7071" class="Bound">A</a><a id="7176" class="Symbol">}}</a> <a id="7179" class="Symbol">{{</a><a id="7181" href="simple_essence.html#7181" class="Bound">_</a> <a id="7183" class="Symbol">:</a> <a id="7185" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="7194" href="simple_essence.html#7083" class="Bound">B</a><a id="7195" class="Symbol">}}</a>
              <a id="7212" class="Symbol">:</a> <a id="7214" class="PrimitiveType">Set</a> <a id="7218" href="simple_essence.html#6107" class="Function">ℓ</a> <a id="7220" class="Keyword">where</a>
  <a id="7228" class="Keyword">constructor</a> <a id="mkLM"></a><a id="7240" href="simple_essence.html#7240" class="InductiveConstructor">mkLM</a>
  <a id="7247" class="Keyword">field</a>
    <a id="LinMap.f"></a><a id="7257" href="simple_essence.html#7257" class="Field">f</a>      <a id="7264" class="Symbol">:</a> <a id="7266" href="simple_essence.html#7071" class="Bound">A</a> <a id="7268" class="Symbol">→</a> <a id="7270" href="simple_essence.html#7083" class="Bound">B</a>

    <a id="LinMap.adds"></a><a id="7277" href="simple_essence.html#7277" class="Field">adds</a>   <a id="7284" class="Symbol">:</a> <a id="7286" class="Symbol">∀</a> <a id="7288" class="Symbol">{</a><a id="7289" href="simple_essence.html#7289" class="Bound">a</a> <a id="7291" href="simple_essence.html#7291" class="Bound">b</a> <a id="7293" class="Symbol">:</a> <a id="7295" href="simple_essence.html#7071" class="Bound">A</a><a id="7296" class="Symbol">}</a>
             <a id="7311" class="Comment">---------------------</a>
           <a id="7344" class="Symbol">→</a> <a id="7346" href="simple_essence.html#7257" class="Field">f</a> <a id="7348" class="Symbol">(</a><a id="7349" href="simple_essence.html#7289" class="Bound">a</a> <a id="7351" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="7353" href="simple_essence.html#7291" class="Bound">b</a><a id="7354" class="Symbol">)</a> <a id="7356" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7358" href="simple_essence.html#7257" class="Field">f</a> <a id="7360" href="simple_essence.html#7289" class="Bound">a</a> <a id="7362" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="7364" href="simple_essence.html#7257" class="Field">f</a> <a id="7366" href="simple_essence.html#7291" class="Bound">b</a>

    <a id="LinMap.scales"></a><a id="7373" href="simple_essence.html#7373" class="Field">scales</a> <a id="7380" class="Symbol">:</a> <a id="7382" class="Symbol">∀</a> <a id="7384" class="Symbol">{</a><a id="7385" href="simple_essence.html#7385" class="Bound">s</a> <a id="7387" class="Symbol">:</a> <a id="7389" href="simple_essence.html#6137" class="Datatype">§</a><a id="7390" class="Symbol">}</a> <a id="7392" class="Symbol">{</a><a id="7393" href="simple_essence.html#7393" class="Bound">a</a> <a id="7395" class="Symbol">:</a> <a id="7397" href="simple_essence.html#7071" class="Bound">A</a><a id="7398" class="Symbol">}</a>
             <a id="7413" class="Comment">-------------------</a>
           <a id="7444" class="Symbol">→</a> <a id="7446" href="simple_essence.html#7257" class="Field">f</a> <a id="7448" class="Symbol">(</a><a id="7449" href="simple_essence.html#7385" class="Bound">s</a> <a id="7451" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="7453" href="simple_essence.html#7393" class="Bound">a</a><a id="7454" class="Symbol">)</a> <a id="7456" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7458" href="simple_essence.html#7385" class="Bound">s</a> <a id="7460" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="7462" href="simple_essence.html#7257" class="Field">f</a> <a id="7464" href="simple_essence.html#7393" class="Bound">a</a>
<a id="7466" class="Keyword">open</a> <a id="7471" href="simple_essence.html#7063" class="Module">LinMap</a> <a id="7478" class="Symbol">{{</a> <a id="7481" class="Symbol">...</a> <a id="7485" class="Symbol">}}</a>

<a id="7489" class="Comment">-- As per Conal&#39;s advice:</a>
<a id="7515" class="Comment">-- ⊸≈ = isEquivalence LinMap.f Eq.isEquivalence</a>
<a id="7563" class="Keyword">postulate</a>
  <a id="⊸≡"></a><a id="7575" href="simple_essence.html#7575" class="Postulate">⊸≡</a> <a id="7578" class="Symbol">:</a> <a id="7580" class="Symbol">{</a><a id="7581" href="simple_essence.html#7581" class="Bound">A</a> <a id="7583" href="simple_essence.html#7583" class="Bound">B</a> <a id="7585" class="Symbol">:</a> <a id="7587" class="PrimitiveType">Set</a> <a id="7591" href="simple_essence.html#5523" class="Bound">a</a><a id="7592" class="Symbol">}</a>
       <a id="7601" class="Symbol">{{</a><a id="7603" href="simple_essence.html#7603" class="Bound">_</a> <a id="7605" class="Symbol">:</a> <a id="7607" href="simple_essence.html#6177" class="Record">Additive</a> <a id="7616" href="simple_essence.html#7581" class="Bound">A</a><a id="7617" class="Symbol">}}</a> <a id="7620" class="Symbol">{{</a><a id="7622" href="simple_essence.html#7622" class="Bound">_</a> <a id="7624" class="Symbol">:</a> <a id="7626" href="simple_essence.html#6177" class="Record">Additive</a> <a id="7635" href="simple_essence.html#7583" class="Bound">B</a><a id="7636" class="Symbol">}}</a>
       <a id="7646" class="Symbol">{{</a><a id="7648" href="simple_essence.html#7648" class="Bound">_</a> <a id="7650" class="Symbol">:</a> <a id="7652" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="7661" href="simple_essence.html#7581" class="Bound">A</a><a id="7662" class="Symbol">}}</a> <a id="7665" class="Symbol">{{</a><a id="7667" href="simple_essence.html#7667" class="Bound">_</a> <a id="7669" class="Symbol">:</a> <a id="7671" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="7680" href="simple_essence.html#7583" class="Bound">B</a><a id="7681" class="Symbol">}}</a>
       <a id="7691" class="Symbol">{</a><a id="7692" href="simple_essence.html#7692" class="Bound">lm₁</a> <a id="7696" href="simple_essence.html#7696" class="Bound">lm₂</a> <a id="7700" class="Symbol">:</a> <a id="7702" href="simple_essence.html#7063" class="Record">LinMap</a> <a id="7709" href="simple_essence.html#7581" class="Bound">A</a> <a id="7711" href="simple_essence.html#7583" class="Bound">B</a><a id="7712" class="Symbol">}</a>
     <a id="7719" class="Symbol">→</a> <a id="7721" href="simple_essence.html#7257" class="Field">LinMap.f</a> <a id="7730" href="simple_essence.html#7692" class="Bound">lm₁</a> <a id="7734" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7736" href="simple_essence.html#7257" class="Field">LinMap.f</a> <a id="7745" href="simple_essence.html#7696" class="Bound">lm₂</a>
       <a id="7756" class="Comment">---------------------------</a>
     <a id="7789" class="Symbol">→</a> <a id="7791" href="simple_essence.html#7692" class="Bound">lm₁</a> <a id="7795" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7797" href="simple_essence.html#7696" class="Bound">lm₂</a>

<a id="7802" class="Keyword">record</a> <a id="VectorSpace"></a><a id="7809" href="simple_essence.html#7809" class="Record">VectorSpace</a> <a id="7821" class="Symbol">(</a><a id="7822" href="simple_essence.html#7822" class="Bound">A</a> <a id="7824" class="Symbol">:</a> <a id="7826" class="PrimitiveType">Set</a> <a id="7830" href="simple_essence.html#5523" class="Bound">a</a><a id="7831" class="Symbol">)</a>
                   <a id="7852" class="Symbol">{{</a><a id="7854" href="simple_essence.html#7854" class="Bound">_</a> <a id="7856" class="Symbol">:</a> <a id="7858" href="simple_essence.html#6177" class="Record">Additive</a> <a id="7867" href="simple_essence.html#7822" class="Bound">A</a><a id="7868" class="Symbol">}}</a> <a id="7871" class="Symbol">{{</a><a id="7873" href="simple_essence.html#7873" class="Bound">_</a> <a id="7875" class="Symbol">:</a> <a id="7877" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="7886" href="simple_essence.html#7822" class="Bound">A</a><a id="7887" class="Symbol">}}</a>
                   <a id="7909" class="Symbol">:</a> <a id="7911" class="PrimitiveType">Set</a> <a id="7915" href="simple_essence.html#6107" class="Function">ℓ</a> <a id="7917" class="Keyword">where</a>
  <a id="7925" class="Keyword">field</a>
    <a id="7935" class="Comment">-- As noted above, seems like I should have to define some properties relating these two.</a>
    <a id="VectorSpace.basisSet"></a><a id="8029" href="simple_essence.html#8029" class="Field">basisSet</a>    <a id="8041" class="Symbol">:</a> <a id="8043" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="8048" href="simple_essence.html#7822" class="Bound">A</a>
    <a id="VectorSpace._·_"></a><a id="8054" href="simple_essence.html#8054" class="Field Operator">_·_</a>         <a id="8066" class="Symbol">:</a> <a id="8068" href="simple_essence.html#7822" class="Bound">A</a> <a id="8070" class="Symbol">→</a> <a id="8072" href="simple_essence.html#7822" class="Bound">A</a> <a id="8074" class="Symbol">→</a> <a id="8076" href="simple_essence.html#6137" class="Datatype">§</a>
    <a id="8082" class="Comment">-- Added while solving the isomorphism below.</a>
    <a id="VectorSpace.·-distrib-⊕"></a><a id="8132" href="simple_essence.html#8132" class="Field">·-distrib-⊕</a> <a id="8144" class="Symbol">:</a> <a id="8146" class="Symbol">∀</a> <a id="8148" class="Symbol">{</a><a id="8149" href="simple_essence.html#8149" class="Bound">a</a> <a id="8151" href="simple_essence.html#8151" class="Bound">b</a> <a id="8153" href="simple_essence.html#8153" class="Bound">c</a> <a id="8155" class="Symbol">:</a> <a id="8157" href="simple_essence.html#7822" class="Bound">A</a><a id="8158" class="Symbol">}</a>
                  <a id="8178" class="Comment">-------------------------------</a>
                <a id="8226" class="Symbol">→</a> <a id="8228" href="simple_essence.html#8149" class="Bound">a</a> <a id="8230" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="8232" class="Symbol">(</a><a id="8233" href="simple_essence.html#8151" class="Bound">b</a> <a id="8235" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="8237" href="simple_essence.html#8153" class="Bound">c</a><a id="8238" class="Symbol">)</a> <a id="8240" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8242" class="Symbol">(</a><a id="8243" href="simple_essence.html#8149" class="Bound">a</a> <a id="8245" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="8247" href="simple_essence.html#8151" class="Bound">b</a><a id="8248" class="Symbol">)</a> <a id="8250" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="8252" class="Symbol">(</a><a id="8253" href="simple_essence.html#8149" class="Bound">a</a> <a id="8255" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="8257" href="simple_essence.html#8153" class="Bound">c</a><a id="8258" class="Symbol">)</a>
    <a id="VectorSpace.·-comm-⊛"></a><a id="8264" href="simple_essence.html#8264" class="Field">·-comm-⊛</a>    <a id="8276" class="Symbol">:</a> <a id="8278" class="Symbol">∀</a> <a id="8280" class="Symbol">{</a><a id="8281" href="simple_essence.html#8281" class="Bound">s</a> <a id="8283" class="Symbol">:</a> <a id="8285" href="simple_essence.html#6137" class="Datatype">§</a><a id="8286" class="Symbol">}</a> <a id="8288" class="Symbol">{</a><a id="8289" href="simple_essence.html#8289" class="Bound">a</a> <a id="8291" href="simple_essence.html#8291" class="Bound">b</a> <a id="8293" class="Symbol">:</a> <a id="8295" href="simple_essence.html#7822" class="Bound">A</a><a id="8296" class="Symbol">}</a>
                  <a id="8316" class="Comment">-------------------------</a>
                <a id="8358" class="Symbol">→</a> <a id="8360" href="simple_essence.html#8289" class="Bound">a</a> <a id="8362" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="8364" class="Symbol">(</a><a id="8365" href="simple_essence.html#8281" class="Bound">s</a> <a id="8367" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="8369" href="simple_essence.html#8291" class="Bound">b</a><a id="8370" class="Symbol">)</a> <a id="8372" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8374" href="simple_essence.html#8281" class="Bound">s</a> <a id="8376" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="8378" class="Symbol">(</a><a id="8379" href="simple_essence.html#8289" class="Bound">a</a> <a id="8381" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="8383" href="simple_essence.html#8291" class="Bound">b</a><a id="8384" class="Symbol">)</a>
    <a id="8390" class="Comment">-- Aha! Here&#39;s that property relating `basisSet` and `(_·_)` I was hunching on.</a>
    <a id="8474" class="Comment">-- Needed to complete the definition of `mk↔`, below.</a>
    <a id="VectorSpace.orthonormal"></a><a id="8532" href="simple_essence.html#8532" class="Field">orthonormal</a> <a id="8544" class="Symbol">:</a> <a id="8546" class="Symbol">∀</a> <a id="8548" class="Symbol">{</a><a id="8549" href="simple_essence.html#8549" class="Bound">f</a> <a id="8551" class="Symbol">:</a> <a id="8553" href="simple_essence.html#7822" class="Bound">A</a> <a id="8555" class="Symbol">→</a> <a id="8557" href="simple_essence.html#6137" class="Datatype">§</a><a id="8558" class="Symbol">}</a>
                <a id="8576" class="Symbol">→</a> <a id="8578" class="Symbol">{</a><a id="8579" href="simple_essence.html#8579" class="Bound">x</a> <a id="8581" class="Symbol">:</a> <a id="8583" href="simple_essence.html#7822" class="Bound">A</a><a id="8584" class="Symbol">}</a>
                  <a id="8604" class="Comment">----------------------------------------------------------</a>
                <a id="8679" class="Symbol">→</a> <a id="8681" class="Symbol">(</a><a id="8682" href="Data.List.Base.html#3726" class="Function">foldl</a> <a id="8688" class="Symbol">(λ</a> <a id="8691" href="simple_essence.html#8691" class="Bound">acc</a> <a id="8695" href="simple_essence.html#8695" class="Bound">v</a> <a id="8697" class="Symbol">→</a> <a id="8699" href="simple_essence.html#8691" class="Bound">acc</a> <a id="8703" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="8705" class="Symbol">(</a><a id="8706" href="simple_essence.html#8549" class="Bound">f</a> <a id="8708" href="simple_essence.html#8695" class="Bound">v</a><a id="8709" class="Symbol">)</a> <a id="8711" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="8713" href="simple_essence.html#8695" class="Bound">v</a><a id="8714" class="Symbol">)</a> <a id="8716" href="simple_essence.html#6290" class="Field">id⊕</a> <a id="8720" href="simple_essence.html#8029" class="Field">basisSet</a><a id="8728" class="Symbol">)</a> <a id="8730" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="8732" href="simple_essence.html#8579" class="Bound">x</a> <a id="8734" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8736" href="simple_essence.html#8549" class="Bound">f</a> <a id="8738" href="simple_essence.html#8579" class="Bound">x</a>
<a id="8740" class="Keyword">open</a> <a id="8745" href="simple_essence.html#7809" class="Module">VectorSpace</a> <a id="8757" class="Symbol">{{</a> <a id="8760" class="Symbol">...</a> <a id="8764" class="Symbol">}}</a>

<a id="8768" class="Comment">-- The Isomorphism I&#39;m trying to prove.</a>
<a id="a⊸§→a"></a><a id="8808" href="simple_essence.html#8808" class="Function">a⊸§→a</a> <a id="8814" class="Symbol">:</a> <a id="8816" class="Symbol">{</a><a id="8817" href="simple_essence.html#8817" class="Bound">A</a> <a id="8819" class="Symbol">:</a> <a id="8821" class="PrimitiveType">Set</a> <a id="8825" href="simple_essence.html#5523" class="Bound">a</a><a id="8826" class="Symbol">}</a>
        <a id="8836" class="Symbol">{{</a><a id="8838" href="simple_essence.html#8838" class="Bound">_</a> <a id="8840" class="Symbol">:</a> <a id="8842" href="simple_essence.html#6177" class="Record">Additive</a> <a id="8851" href="simple_essence.html#8817" class="Bound">A</a><a id="8852" class="Symbol">}}</a> <a id="8855" class="Symbol">{{</a><a id="8857" href="simple_essence.html#8857" class="Bound">_</a> <a id="8859" class="Symbol">:</a> <a id="8861" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="8870" href="simple_essence.html#8817" class="Bound">A</a><a id="8871" class="Symbol">}}</a>
        <a id="8882" class="Symbol">{{</a><a id="8884" href="simple_essence.html#8884" class="Bound">_</a> <a id="8886" class="Symbol">:</a> <a id="8888" href="simple_essence.html#7809" class="Record">VectorSpace</a> <a id="8900" href="simple_essence.html#8817" class="Bound">A</a><a id="8901" class="Symbol">}}</a>
        <a id="8912" class="Comment">-------------------------------------</a>
      <a id="8956" class="Symbol">→</a> <a id="8958" href="simple_essence.html#7063" class="Record">LinMap</a> <a id="8965" href="simple_essence.html#8817" class="Bound">A</a> <a id="8967" href="simple_essence.html#6137" class="Datatype">§</a> <a id="8969" class="Symbol">→</a> <a id="8971" href="simple_essence.html#8817" class="Bound">A</a>
<a id="8973" href="simple_essence.html#8808" class="Function">a⊸§→a</a> <a id="8979" class="Symbol">=</a> <a id="8981" class="Symbol">λ</a> <a id="8983" class="Symbol">{</a> <a id="8985" href="simple_essence.html#8985" class="Bound">lm</a> <a id="8988" class="Symbol">→</a> <a id="8990" href="Data.List.Base.html#3726" class="Function">foldl</a> <a id="8996" class="Symbol">(λ</a> <a id="8999" href="simple_essence.html#8999" class="Bound">acc</a> <a id="9003" href="simple_essence.html#9003" class="Bound">v</a> <a id="9005" class="Symbol">→</a> <a id="9007" href="simple_essence.html#8999" class="Bound">acc</a> <a id="9011" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="9013" class="Symbol">(</a><a id="9014" href="simple_essence.html#7257" class="Field">LinMap.f</a> <a id="9023" href="simple_essence.html#8985" class="Bound">lm</a> <a id="9026" href="simple_essence.html#9003" class="Bound">v</a><a id="9027" class="Symbol">)</a> <a id="9029" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="9031" href="simple_essence.html#9003" class="Bound">v</a><a id="9032" class="Symbol">)</a> <a id="9034" href="simple_essence.html#6290" class="Field">id⊕</a> <a id="9038" href="simple_essence.html#8029" class="Field">basisSet</a> <a id="9047" class="Symbol">}</a>

<a id="a⊸§←a"></a><a id="9050" href="simple_essence.html#9050" class="Function">a⊸§←a</a> <a id="9056" class="Symbol">:</a> <a id="9058" class="Symbol">{</a><a id="9059" href="simple_essence.html#9059" class="Bound">A</a> <a id="9061" class="Symbol">:</a> <a id="9063" class="PrimitiveType">Set</a> <a id="9067" href="simple_essence.html#5523" class="Bound">a</a><a id="9068" class="Symbol">}</a>
        <a id="9078" class="Symbol">{{</a><a id="9080" href="simple_essence.html#9080" class="Bound">_</a> <a id="9082" class="Symbol">:</a> <a id="9084" href="simple_essence.html#6177" class="Record">Additive</a> <a id="9093" href="simple_essence.html#9059" class="Bound">A</a><a id="9094" class="Symbol">}}</a> <a id="9097" class="Symbol">{{</a><a id="9099" href="simple_essence.html#9099" class="Bound">_</a> <a id="9101" class="Symbol">:</a> <a id="9103" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="9112" href="simple_essence.html#9059" class="Bound">A</a><a id="9113" class="Symbol">}}</a>
        <a id="9124" class="Symbol">{{</a><a id="9126" href="simple_essence.html#9126" class="Bound">_</a> <a id="9128" class="Symbol">:</a> <a id="9130" href="simple_essence.html#7809" class="Record">VectorSpace</a> <a id="9142" href="simple_essence.html#9059" class="Bound">A</a><a id="9143" class="Symbol">}}</a>
        <a id="9154" class="Comment">-------------------------------------</a>
      <a id="9198" class="Symbol">→</a> <a id="9200" href="simple_essence.html#9059" class="Bound">A</a> <a id="9202" class="Symbol">→</a> <a id="9204" href="simple_essence.html#7063" class="Record">LinMap</a> <a id="9211" href="simple_essence.html#9059" class="Bound">A</a> <a id="9213" href="simple_essence.html#6137" class="Datatype">§</a>
<a id="9215" href="simple_essence.html#9050" class="Function">a⊸§←a</a> <a id="9221" class="Symbol">=</a> <a id="9223" class="Symbol">λ</a> <a id="9225" class="Symbol">{</a> <a id="9227" href="simple_essence.html#9227" class="Bound">a</a> <a id="9229" class="Symbol">→</a> <a id="9231" href="simple_essence.html#7240" class="InductiveConstructor">mkLM</a> <a id="9236" class="Symbol">(</a><a id="9237" href="simple_essence.html#9227" class="Bound">a</a> <a id="9239" href="simple_essence.html#8054" class="Field Operator">·_</a><a id="9241" class="Symbol">)</a> <a id="9243" href="simple_essence.html#8132" class="Field">·-distrib-⊕</a> <a id="9255" href="simple_essence.html#8264" class="Field">·-comm-⊛</a> <a id="9264" class="Symbol">}</a>

<a id="9267" class="Comment">-- Danger, Will Robinson!</a>
<a id="9293" class="Keyword">postulate</a>
  <a id="x·z≡y·z→x≡y"></a><a id="9305" href="simple_essence.html#9305" class="Postulate">x·z≡y·z→x≡y</a> <a id="9317" class="Symbol">:</a> <a id="9319" class="Symbol">{</a><a id="9320" href="simple_essence.html#9320" class="Bound">A</a> <a id="9322" class="Symbol">:</a> <a id="9324" class="PrimitiveType">Set</a> <a id="9328" href="simple_essence.html#5523" class="Bound">a</a><a id="9329" class="Symbol">}</a>
                <a id="9347" class="Symbol">{{</a><a id="9349" href="simple_essence.html#9349" class="Bound">_</a> <a id="9351" class="Symbol">:</a> <a id="9353" href="simple_essence.html#6177" class="Record">Additive</a> <a id="9362" href="simple_essence.html#9320" class="Bound">A</a><a id="9363" class="Symbol">}}</a> <a id="9366" class="Symbol">{{</a><a id="9368" href="simple_essence.html#9368" class="Bound">_</a> <a id="9370" class="Symbol">:</a> <a id="9372" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="9381" href="simple_essence.html#9320" class="Bound">A</a><a id="9382" class="Symbol">}}</a> <a id="9385" class="Symbol">{{</a><a id="9387" href="simple_essence.html#9387" class="Bound">_</a> <a id="9389" class="Symbol">:</a> <a id="9391" href="simple_essence.html#7809" class="Record">VectorSpace</a> <a id="9403" href="simple_essence.html#9320" class="Bound">A</a><a id="9404" class="Symbol">}}</a>
                <a id="9423" class="Symbol">{</a><a id="9424" href="simple_essence.html#9424" class="Bound">x</a> <a id="9426" href="simple_essence.html#9426" class="Bound">y</a> <a id="9428" class="Symbol">:</a> <a id="9430" href="simple_essence.html#9320" class="Bound">A</a><a id="9431" class="Symbol">}</a>
              <a id="9447" class="Symbol">→</a> <a id="9449" class="Symbol">(∀</a> <a id="9452" class="Symbol">{</a><a id="9453" href="simple_essence.html#9453" class="Bound">z</a> <a id="9455" class="Symbol">:</a> <a id="9457" href="simple_essence.html#9320" class="Bound">A</a><a id="9458" class="Symbol">}</a> <a id="9460" class="Symbol">→</a> <a id="9462" href="simple_essence.html#9424" class="Bound">x</a> <a id="9464" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="9466" href="simple_essence.html#9453" class="Bound">z</a> <a id="9468" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9470" href="simple_essence.html#9426" class="Bound">y</a> <a id="9472" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="9474" href="simple_essence.html#9453" class="Bound">z</a><a id="9475" class="Symbol">)</a>
                <a id="9493" class="Comment">-----------------------------------------------------------</a>
              <a id="9567" class="Symbol">→</a> <a id="9569" href="simple_essence.html#9424" class="Bound">x</a> <a id="9571" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9573" href="simple_essence.html#9426" class="Bound">y</a>
<a id="9575" class="Comment">-- ToDo: Try replacing postulate above w/ definition below.</a>
<a id="9635" class="Comment">--       (Perhaps, a proof by contradiction, starting w/ `x ≢ y`?)</a>
<a id="9702" class="Comment">-- x·z≡y·z→x≡y x·z≡y·z = {!!}</a>

<a id="a⊸§↔a"></a><a id="9733" href="simple_essence.html#9733" class="Function">a⊸§↔a</a> <a id="9739" class="Symbol">:</a> <a id="9741" class="Symbol">{</a><a id="9742" href="simple_essence.html#9742" class="Bound">A</a> <a id="9744" class="Symbol">:</a> <a id="9746" class="PrimitiveType">Set</a> <a id="9750" href="simple_essence.html#5523" class="Bound">a</a><a id="9751" class="Symbol">}</a>
        <a id="9761" class="Symbol">{{</a><a id="9763" href="simple_essence.html#9763" class="Bound">_</a> <a id="9765" class="Symbol">:</a> <a id="9767" href="simple_essence.html#6177" class="Record">Additive</a> <a id="9776" href="simple_essence.html#9742" class="Bound">A</a><a id="9777" class="Symbol">}}</a> <a id="9780" class="Symbol">{{</a><a id="9782" href="simple_essence.html#9782" class="Bound">_</a> <a id="9784" class="Symbol">:</a> <a id="9786" href="simple_essence.html#6791" class="Record">Scalable</a> <a id="9795" href="simple_essence.html#9742" class="Bound">A</a><a id="9796" class="Symbol">}}</a>
        <a id="9807" class="Symbol">{{</a><a id="9809" href="simple_essence.html#9809" class="Bound">_</a> <a id="9811" class="Symbol">:</a> <a id="9813" href="simple_essence.html#7809" class="Record">VectorSpace</a> <a id="9825" href="simple_essence.html#9742" class="Bound">A</a><a id="9826" class="Symbol">}}</a>
        <a id="9837" class="Comment">-------------------------------------</a>
      <a id="9881" class="Symbol">→</a> <a id="9883" class="Symbol">(</a><a id="9884" href="simple_essence.html#7063" class="Record">LinMap</a> <a id="9891" href="simple_essence.html#9742" class="Bound">A</a> <a id="9893" href="simple_essence.html#6137" class="Datatype">§</a><a id="9894" class="Symbol">)</a> <a id="9896" href="Function.Bundles.html#7902" class="Function Operator">↔</a> <a id="9898" href="simple_essence.html#9742" class="Bound">A</a>
<a id="9900" href="simple_essence.html#9733" class="Function">a⊸§↔a</a> <a id="9906" class="Symbol">{</a><a id="9907" href="simple_essence.html#9907" class="Bound">A</a><a id="9908" class="Symbol">}</a> <a id="9910" class="Symbol">=</a>
  <a id="9914" href="Function.Bundles.html#9488" class="Function">mk↔</a> <a id="9918" class="Symbol">{</a><a id="9919" class="Argument">f</a> <a id="9921" class="Symbol">=</a> <a id="9923" href="simple_essence.html#8808" class="Function">a⊸§→a</a><a id="9928" class="Symbol">}</a> <a id="9930" class="Symbol">{</a><a id="9931" class="Argument">f⁻¹</a> <a id="9935" class="Symbol">=</a> <a id="9937" href="simple_essence.html#9050" class="Function">a⊸§←a</a><a id="9942" class="Symbol">}</a>
      <a id="9950" class="Symbol">(</a> <a id="9952" class="Symbol">(λ</a> <a id="9955" class="Symbol">{</a><a id="9956" href="simple_essence.html#9956" class="Bound">x</a> <a id="9958" class="Symbol">→</a> <a id="9960" href="Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
                  <a id="9984" href="simple_essence.html#8808" class="Function">a⊸§→a</a> <a id="9990" class="Symbol">(</a><a id="9991" href="simple_essence.html#9050" class="Function">a⊸§←a</a> <a id="9997" href="simple_essence.html#9956" class="Bound">x</a><a id="9998" class="Symbol">)</a>
                <a id="10016" href="Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
                  <a id="10038" href="simple_essence.html#8808" class="Function">a⊸§→a</a> <a id="10044" class="Symbol">(</a><a id="10045" href="simple_essence.html#7240" class="InductiveConstructor">mkLM</a> <a id="10050" class="Symbol">(</a><a id="10051" href="simple_essence.html#9956" class="Bound">x</a> <a id="10053" href="simple_essence.html#8054" class="Field Operator">·_</a><a id="10055" class="Symbol">)</a> <a id="10057" href="simple_essence.html#8132" class="Field">·-distrib-⊕</a> <a id="10069" href="simple_essence.html#8264" class="Field">·-comm-⊛</a><a id="10077" class="Symbol">)</a>
                <a id="10095" href="Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
                  <a id="10117" href="Data.List.Base.html#3726" class="Function">foldl</a> <a id="10123" class="Symbol">(λ</a> <a id="10126" href="simple_essence.html#10126" class="Bound">acc</a> <a id="10130" href="simple_essence.html#10130" class="Bound">v</a> <a id="10132" class="Symbol">→</a> <a id="10134" href="simple_essence.html#10126" class="Bound">acc</a> <a id="10138" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="10140" class="Symbol">(</a><a id="10141" href="simple_essence.html#9956" class="Bound">x</a> <a id="10143" href="simple_essence.html#8054" class="Field Operator">·</a> <a id="10145" href="simple_essence.html#10130" class="Bound">v</a><a id="10146" class="Symbol">)</a> <a id="10148" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="10150" href="simple_essence.html#10130" class="Bound">v</a><a id="10151" class="Symbol">)</a> <a id="10153" href="simple_essence.html#6290" class="Field">id⊕</a> <a id="10157" href="simple_essence.html#8029" class="Field">basisSet</a>
                <a id="10182" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10185" href="simple_essence.html#9305" class="Postulate">x·z≡y·z→x≡y</a> <a id="10197" class="Symbol">(</a><a id="10198" href="simple_essence.html#8532" class="Field">orthonormal</a> <a id="10210" class="Symbol">{</a><a id="10211" class="Argument">f</a> <a id="10213" class="Symbol">=</a> <a id="10215" class="Symbol">(</a><a id="10216" href="simple_essence.html#9956" class="Bound">x</a> <a id="10218" href="simple_essence.html#8054" class="Field Operator">·_</a><a id="10220" class="Symbol">)})</a> <a id="10224" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
                  <a id="10244" href="simple_essence.html#9956" class="Bound">x</a>
                <a id="10262" href="Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a><a id="10263" class="Symbol">})</a>
      <a id="10272" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10274" class="Symbol">λ</a> <a id="10276" class="Symbol">{</a><a id="10277" href="simple_essence.html#10277" class="Bound">lm</a> <a id="10280" class="Symbol">→</a> <a id="10282" href="Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
                  <a id="10306" href="simple_essence.html#9050" class="Function">a⊸§←a</a> <a id="10312" class="Symbol">(</a><a id="10313" href="simple_essence.html#8808" class="Function">a⊸§→a</a> <a id="10319" href="simple_essence.html#10277" class="Bound">lm</a><a id="10321" class="Symbol">)</a>
                <a id="10339" href="Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
                  <a id="10361" href="simple_essence.html#9050" class="Function">a⊸§←a</a> <a id="10367" class="Symbol">(</a><a id="10368" href="Data.List.Base.html#3726" class="Function">foldl</a> <a id="10374" class="Symbol">(λ</a> <a id="10377" href="simple_essence.html#10377" class="Bound">acc</a> <a id="10381" href="simple_essence.html#10381" class="Bound">v</a> <a id="10383" class="Symbol">→</a> <a id="10385" href="simple_essence.html#10377" class="Bound">acc</a> <a id="10389" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="10391" class="Symbol">(</a><a id="10392" href="simple_essence.html#7257" class="Field">LinMap.f</a> <a id="10401" href="simple_essence.html#10277" class="Bound">lm</a> <a id="10404" href="simple_essence.html#10381" class="Bound">v</a><a id="10405" class="Symbol">)</a> <a id="10407" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="10409" href="simple_essence.html#10381" class="Bound">v</a><a id="10410" class="Symbol">)</a> <a id="10412" href="simple_essence.html#6290" class="Field">id⊕</a> <a id="10416" href="simple_essence.html#8029" class="Field">basisSet</a><a id="10424" class="Symbol">)</a>
                <a id="10442" href="Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
                  <a id="10464" href="simple_essence.html#7240" class="InductiveConstructor">mkLM</a> <a id="10469" class="Symbol">((</a><a id="10471" href="Data.List.Base.html#3726" class="Function">foldl</a> <a id="10477" class="Symbol">(λ</a> <a id="10480" href="simple_essence.html#10480" class="Bound">acc</a> <a id="10484" href="simple_essence.html#10484" class="Bound">v</a> <a id="10486" class="Symbol">→</a> <a id="10488" href="simple_essence.html#10480" class="Bound">acc</a> <a id="10492" href="simple_essence.html#6303" class="Field Operator">⊕</a> <a id="10494" class="Symbol">(</a><a id="10495" href="simple_essence.html#7257" class="Field">LinMap.f</a> <a id="10504" href="simple_essence.html#10277" class="Bound">lm</a> <a id="10507" href="simple_essence.html#10484" class="Bound">v</a><a id="10508" class="Symbol">)</a> <a id="10510" href="simple_essence.html#6904" class="Field Operator">⊛</a> <a id="10512" href="simple_essence.html#10484" class="Bound">v</a><a id="10513" class="Symbol">)</a> <a id="10515" href="simple_essence.html#6290" class="Field">id⊕</a> <a id="10519" href="simple_essence.html#8029" class="Field">basisSet</a><a id="10527" class="Symbol">)</a><a id="10528" href="simple_essence.html#8054" class="Field Operator">·_</a><a id="10530" class="Symbol">)</a>
                       <a id="10555" href="simple_essence.html#8132" class="Field">·-distrib-⊕</a> <a id="10567" href="simple_essence.html#8264" class="Field">·-comm-⊛</a>
                <a id="10592" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10595" href="simple_essence.html#7575" class="Postulate">⊸≡</a> <a id="10598" class="Symbol">(</a> <a id="10600" href="simple_essence.html#6056" class="Postulate">extensionality</a>
                          <a id="10641" class="Symbol">(</a> <a id="10643" class="Symbol">λ</a> <a id="10645" href="simple_essence.html#10645" class="Bound">x</a> <a id="10647" class="Symbol">→</a> <a id="10649" href="simple_essence.html#8532" class="Field">orthonormal</a> <a id="10661" class="Symbol">{</a><a id="10662" class="Argument">f</a> <a id="10664" class="Symbol">=</a> <a id="10666" href="simple_essence.html#7257" class="Field">LinMap.f</a> <a id="10675" href="simple_essence.html#10277" class="Bound">lm</a><a id="10677" class="Symbol">}</a> <a id="10679" class="Symbol">{</a><a id="10680" class="Argument">x</a> <a id="10682" class="Symbol">=</a> <a id="10684" href="simple_essence.html#10645" class="Bound">x</a><a id="10685" class="Symbol">}</a> <a id="10687" class="Symbol">)</a>
                      <a id="10711" class="Symbol">)</a>
                 <a id="10730" href="Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
                  <a id="10750" href="simple_essence.html#10277" class="Bound">lm</a>
                <a id="10769" href="Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a><a id="10770" class="Symbol">}</a>
      <a id="10778" class="Symbol">)</a>

<a id="10781" class="Comment">-- This, done in response to Conal&#39;s suggestion of using `Equivalence`, instead of</a>
<a id="10864" class="Comment">-- `Equality`, compiles fine but seems too easy and too weak.</a>
<a id="10926" class="Comment">-- There&#39;s no guarantee of returning back where we started after a double pass, for instance.</a>
<a id="11020" class="Comment">-- I think that I didn&#39;t fully grok the hint he was giving me.</a>
<a id="11083" class="Comment">--</a>
<a id="11086" class="Comment">-- a⊸§⇔a : {A : Set a}</a>
<a id="11109" class="Comment">--         {{_ : Additive A}} {{_ : Scalable A}}</a>
<a id="11158" class="Comment">--         {{_ : VectorSpace A}}</a>
<a id="11191" class="Comment">--         -------------------------------------</a>
<a id="11240" class="Comment">--       → (LinMap A §) ⇔ A</a>
<a id="11268" class="Comment">-- a⊸§⇔a {A} = mk⇔ a⊸§→a a⊸§←a</a>

</pre>
